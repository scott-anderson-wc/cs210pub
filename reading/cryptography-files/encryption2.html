<!DOCTYPE HTML PUBLIC
          "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>CS110: Encryption</title>
   <meta name="author" content="Scott D. Anderson and the CS110 Staff">
   <meta name="description"
        content="described various private and public excryption schemes">
   <meta name="keywords"
        content="caesar vigenere enigma RSA public private encryption">
   <link rel="stylesheet" type="text/css" href="../../cs110-main-style.css">
   <script type="text/JavaScript" src="../../js/cookies.js"></script>
   <script type="text/JavaScript" src="../../js/addOnLoad.js"></script>
   <script type="text/JavaScript" src="../../js/TOC.js"></script>
   <script type="text/JavaScript" src="../../js/verbatim.js"></script>
</head>
<body>

<!-- [lyn, 5/4/09] Fixed broken footer -->
<!-- Scott Fall 2011, added JS forms to do Vigenere and to email 
  Vigenere.  I'd like to do RSA, too.  -->


<H1>Encryption</H1>
         
<div id="insert_TOC_here"></div>
         
<P>Today, we'll talk about how machines can communicate in a
<EM>secure</EM> way.  A little while ago, we talked about analog and
digital signals, and this lecture will remind you of that one, but we're
talking about a higher level: not just how information gets from point A
to Point B, but how it can get there without anyone in between knowing
what is being said.
         
<P>Lots of us had fun with secret codes and such when we were kids.
We'd get <em>secret decoder rings</em> in our cereal boxes and make up
messages to send to each other.  Could be useful if they were
intercepted by the teacher!  We hope that today's lecture evokes that
sense of fun.

<p>A <a href="handout.html">condensed version of these notes</a> can be found here.
         
<H2 id="cast">The Cast of Characters</H2>
         
<P>When we discuss encryption, it's traditional to name the people
involved, just so we can keep things straight.  The cast of our little
drama is:
         
<UL>
  <li>Alice, who wants to say something privately to Bob
            
  <li>Bob, who wants to hear from Alice
            
  <li>Eve, the person who is trying to eavesdrop on their conversation.

  <li>Mallory, the person who is maliciously trying to interfere with
  their conversation
</UL>
         
<P>The story is that Alice is sending Bob a message through some insecure
medium (not whispering in his ear): think postcard or radio.  Alice might
be a field agent and Bob is her contact at HQ.  Alice and Bob might not
even know each other: perhaps Alice is trying to persuade Bob to defect,
and Eve is trying to find traitors.
         
<H2 id="media">Media</H2>
         
<P>The messages might be sent by radio, or phone, or email, or carrier
pigeon. All media are potentially insecure. Radio waves can be picked up
by other receivers, phone wires can be tapped, as can computer
networks. Even carrier pigeons can be captured.
         
<H2 id="ciphers">Ciphers</H2>
         
<P>One approach is to put the message in <EM>code</EM>.  Humans have
invented lots of codes in history, and code-making and code-breaking
have often been pivotal.  Indeed, Alan Turing and his code-breakers in
England may have done more to win WWII against Hitler than General
Patton, because they were able to break the codes sent with the
<em>Enigma</em> machine used by the Germans.  Similarly, the Navajo
Indians, who used their native language as an unbreakable code in the
war in the Pacific, contributed greatly to the war effort without ever
firing a shot.
         
<P>Terminology:
         
<DL>

            <DT>plaintext</DT>
            
            <DD>(n) the message we want to send, in readable form</DD>
            
            <DT>ciphertext</DT>
            
            <DD>(n) the message in coded form, unreadable without special
            information</DD>
            
            <DT>encrypt</DT>
            
            <DD>(v) to turn plaintext into ciphertext</DD>
            
            <DT>decrypt</DT>
            
            <DD>(v) to turn ciphertext back into plaintext</DD>
            
            <DT>cryptanalysis</DT>
            
            <DD>(n) cracking a code; the attempt to decrypt without
            the required special information</DD>
            
            <DT>cryptography</DT>
            
            <DD>(n) The study of codes and code-breaking.</DD>
         </DL>
         
<H2 id="caesar">Caesar Codes</H2>
         
<P>Caesar codes are named because Julius Caesar used them to
communicate with his troops, so they're hardly new. They're also not
particularly hard to break, but if you have to write your message on a
postcard, it's better than nothing.  The idea is <EM>letter
substitution</EM>. A popular and easy way of doing it is
<em>rotating:</em> Imagine the letters of our message are each printed
on a wheel, and we simply turn the wheels so each letter is replaced
by one that is <i>n</i> letters before or after it in the alphabet.  For
example, we replace each letter with the one preceding it in the
alphabet (and &ldquo;A&rdquo; is replaced with &ldquo;Z&rdquo;).
         
         <BLOCKQUOTE><TABLE>
               <TR>
                  <Th>
                     <P>Plaintext:
                  </Th>
                  <TD>
                     <P>IBM
                  </TD>
               </TR>
               <TR>
                  <Th>
                     <P>Ciphertext:
                  </Th>
                  <TD>
                     <P>HAL
                  </TD>
               </TR>
            </TABLE>
         </BLOCKQUOTE>
         
<P>(You may remember that the computer in Arthur C. Clarke's classic
science fiction novel <I>2001: A Space Odyssey </I> was the HAL 9000. Many
people believe this was a thinly veiled reference to IBM, using a -1
rotation code.)
         
<P>Caesar actually used a rotation of 3, so A was written as D, B as
E, and so forth. Thus, &ldquo;ATTACK&rdquo; would be sent as
&ldquo;DWWDFN&rdquo;.
         
<P>Another popular Caesar code is called <em>rot13</em> and has been
used for many years on the Internet as a way to hide things from
inadvertent reading, such as movie spoilers or dirty jokes.  You have
to decode it using rot13 to read the spoiler or the dirty
joke.  Rot13 is just a Caesar code incrementing each letter by 13. This
is convenient because you can decode using the same software as
encoding, since rotating twice by 13 brings a letter back to where it
started.
         
<P>If you want to encrypt using a Caesar code by hand, you can use the
following form. Choose an amount to rotate by, then write your message
using the letter from the cipher alphabet instead of the one from the
plain alphabet &mdash; in other words, the one below the one you
really mean. For example, setting <code>rotation</code> to 1, you can
see &ldquo;B&rdquo; below &ldquo;A&rdquo; and &ldquo;C&rdquo; below
&ldquo;B&rdquo; and so forth.  Setting it to 25, you can see
&ldquo;H&rdquo; below &ldquo;I&rdquo; and &ldquo;A&rdquo; below
&ldquo;B&rdquo; and &ldquo;L&rdquo; below &ldquo;M&rdquo;, giving
&ldquo;IBM&rdquo; for &ldquo;HAL&rdquo;.

<SCRIPT type="text/JavaScript">
const charCodeA = 'A'.charCodeAt(0); 
const charCodeZ = 'Z'.charCodeAt(0);

// returns a new string containing one character that is the n-place
// rotation of the first character of s, if s is a string, and the
// character whose ASCII value is s, if s is a number.

function rotate(s, n) {
    if( typeof(s) == "string" ) {
        x = s.charCodeAt(0);
        y = ((x - charCodeA + n) % 26) + charCodeA;
        return String.fromCharCode(y);
    } else if( typeof(s) == "number" ) {
        x = s;
        y = ((x - charCodeA + n) % 26) + charCodeA;
        return y;
    } else {
        console.log("Can't rotate "+s);
    }
}

function rotateAlphabet(n) {
    n = parseInt(n);
    while(n<0) {
       n = n + 26;
    }
    r = '';
    for(i = A; i <= Z; i++) {
        r += String.fromCharCode(rotate(i, n));
    }
    return r;
}
</SCRIPT>

<FORM ACTION="" METHOD="POST" name="caesar1">
<TABLE>
    <TR>
    <TD> <P>rotation </TD>
    <TD>
        <P><INPUT TYPE=text NAME=amount VALUE="1" SIZE=2
                  onchange="document.caesar1.after.value=rotateAlphabet(this.value)">
    </TD>
    </TR>
    <TR>
    <TD> <P>plain alphabet </TD>
    <TD>
        <P><INPUT TYPE=text NAME=name VALUE="ABCDEFGHIJKLMNOPQRSTUVWXYZ" SIZE=40
                  onchange="this.value=rotateAlphabet(0)">
    </TD>
    </TR>
    <TR>
    <TD> <P>cipher alphabet </TD>
    <TD>
        <P><INPUT TYPE=text NAME=after VALUE="BCDEFGHIJKLMNOPQRSTUVWXYZA" SIZE=40
                  onchange="this.value=rotateAlphabet(document.caesar1.amount.value)">
    </TD>
    </TR>
</TABLE>
         
</FORM>
         
<div class="ex"><span class="ex">Exercise 1</span>

<p>Use the form above to translate some simple words into code. Translate
the first two using Caesar's code (rotate by 3) and the last by
rot13.

<TABLE BORDER=1>
  <TR> <TH> <P>plaintext </TH> <TH> <P>ciphertext </TH> </TR>
  <TR>
      <TD> <P>BY SEA </TD>
      <TD> <P>&nbsp; </TD>
  </TR>
  <TR>
    <TD> <P>BY LAND </TD>
    <TD> <P>&nbsp; </TD>
  </TR>
  <TR>
    <TD> <P>ATTACK </TD>
    <TD> <P>&nbsp; </TD>
  </TR>
</TABLE>
         
<P>You can check your answers and try out other Caesar codes using the
following form. Note that this form converts the string to
uppercase. Also, it only rotates the letters; it leaves the numbers,
punctuation and other characters alone.  It could be easily re-written to
handle more stuff.

</div>

<SCRIPT type="text/JavaScript">

function encrypt(plain,amount) {
    n = parseInt(amount);
    r = '';
    plain =  plain.toUpperCase();
    for(i=0; i<plain.length ; i++) {
        c = plain.charCodeAt(i);
        if( charCodeA<= c && c<= charCodeZ ) {
            c = rotate(c,n);
        }
        s = String.fromCharCode(c);
        r += s;
    }
    return r;
}

function decrypt(cipher,amount) {
    return encrypt(cipher,26-amount);
}

function encryptForm() {
    p = document.caesar.plaintext.value;
    a = document.caesar.amount.value;
    c = encrypt(p,a);
    document.caesar.ciphertext.value = c;
}

function decryptForm() {
    c = document.caesar.ciphertext.value;
    a = document.caesar.amount.value;
    p = decrypt(c,a);
    document.caesar.plaintext.value = p;
}
</SCRIPT>

<FORM ACTION="" METHOD=POST name=caesar>
    <P><TABLE>
       <TR>
          <TD> <P>rotation amount: </TD>
          <TD> <P><INPUT TYPE=text NAME=amount VALUE="" SIZE=2> </TD>
       </TR>
       <TR>
          <TD> <P>plaintext: </TD>
          <TD> <P><INPUT TYPE=text NAME=plaintext VALUE="" SIZE=30> </TD>
       </TR>
       <TR>
          <TD> <P>ciphertext: </TD>
          <TD> <P><INPUT TYPE=text NAME=ciphertext VALUE="" SIZE=30> </TD>
       </TR>
       <TR>
          <TD> <P><INPUT TYPE=button NAME=Button VALUE="Encrypt" onclick="encryptForm()"> </TD>
          <TD> <P><INPUT TYPE=button NAME=Button VALUE="Decrypt" onclick="decryptForm()"> </TD>
       </TR>
</TABLE>
         
</FORM>
         
<P>So, now you and a friend can exchange secret messages, say by email,
just by encrypting them using this form. You just have to agree on a
rotation amount (and keep it secret!).
         
<H2 id="ascii">ASCII Codes implementing Caesar Ciphers</H2>
         
<P>Earlier, we ignored punctuation and anything other than a
letter. Obviously, that makes for a bad code. What we really should do is
treat all characters the same. How is this done? First, we have to say
what a character is.
         
<P>As you know, everything in a computer is just numbers.  How does it
deal with characters? As you remember from an earlier lecture, early
computer designers agreed on a set of characters and a standard number for
each one. For example, A is represented with 65. One such system was
ASCII: American Standard Code for Information Interchange. Here's part of
the ASCII code:
         
<script type="text/JavaScript">

document.write("<p><table cols=9 border=1>\n");
document.write("<tr><th>&nbsp;<\/th>");
for(col=0; col < 8; col++ ) {
    document.write("<th>"+col+"<\/th>");
}
document.write("<\/tr>");
for(row=32; row<128; row += 8) {
   document.write("<tr><th>"+row+"<\/th>");
   for(col=0; col < 8; col++ ) {
       document.write("<td class=\"c\">");
       code=row+col;
       if(code == 32) document.write("SPC");
       else if(code == 38) document.write("&amp;");
       else if(code == 60) document.write("&lt;");
       else if(code == 62) document.write("&gt;");
       else if(code == 127) document.write("DEL");
       else document.write(String.fromCharCode(code));
       document.write("<\/td>");
   }
   document.write("<\/tr>\n");
}
document.write("<\/table>\n");
</script>
     
<p>You read this table just like an addition table.  Add together the row
and column headers, and you find the numerical value (ASCII code) of the
character at the intersection of that row and column.

<P><STRONG>Note:</STRONG> The ASCII code is <EM>not</EM> about encryption;
it's just a standard for numbering characters. The existence of such a
numbering means that we can do rotation codes numerically, like this:
         
<PRE>
   encoded_char = (plaintext_char + rotation_amount) % 128;
</PRE>
         
<p>ASCII is now being supplanted by UNICODE, which is a vastly larger
code, designed to handle all the world's languages.
         
<H2 id="code_breaking">Code Breaking</H2>
         
<p><q>Breaking</q> a code (that is, reading encrypted messages without
  having the secret information) is
  called <a href="http://en.wikipedia.org/wiki/Cryptanalysis"><em>cryptanalysis</em></a>.

<p>Caesar ciphers are relatively easy to break, as is any cipher based
  just on substitution of letters. For example, the most common letter in
  the ciphertext is probably the encypted form of a very common letter,
  such as &ldquo;e&rdquo; or &ldquo;t&rdquo; or &ldquo;a&rdquo;.  With
  more sophisticated statistics, and trial and error, both of which
  computers are good at, it's fairly easy to crack a substitution cipher.
         
<H2 id="vigenere">Vigen&egrave;re Cipher</H2>
         
<P>One way to spoil the statistics of a Caesar cipher is to use
multiple Caesar ciphers. In other words, suppose we rotate the first
letter of the plaintext by 2, the second letter by 0, and the third
letter by 19. Then we repeat, rotating by 2, 0, 19, until we're done
with the plaintext.  Such a technique is called a <em>Vigenere
Cipher,</em> mis-attribute to Blaise de Vigen&egrave;re from the court
of Henry III of France in the sixteenth century. It was considered
unbreakable for some 300 years!
         
<P>Another way to think of the Vigen&egrave;re Cipher is as follows. Write
down a <em>keyword,</em> such as &ldquo;cat&rdquo;.  Then, use the
index of each letter as the amount to rotate.  For example, if the
keyword is &ldquo;cat&rdquo;, then we will use a 2 rotation, a 0
rotation, and a 19 rotation (&ldquo;t&rdquo; is the 19<sup>th</sup>
letter of the alphabet if you start from zero: <q>A</q> is the 0<sup>th</sup> letter).  Write down the keyword above the
plaintext and use it to select the correct rotation. It helps to have
a table of all the rotations:

<SCRIPT type="text/JavaScript">
//for(i=0; i<13; i++) { document.write("<p>"); }

document.write("<p><table><tr><th>Char<\/th>");

for(i=charCodeA; i<=charCodeZ; i++) {
   document.write("<th>"+String.fromCharCode(i)+"<\/th>");
}
document.write("<th style='padding-left: 3em'>Rot<\/th>");
document.write("<\/tr>");
for(j=charCodeA; j<=charCodeZ; j++) {
    document.write("<tr><th>"+String.fromCharCode(j)+"<\/th>");
    for(i=charCodeA; i<=charCodeZ; i++) {
        document.write("<td>"+String.fromCharCode(rotate(i,j-charCodeA))+"<\/td>");
    }
    // show the numerical amount of the rotation
    document.write("<td style='padding-left: 3em;'>"+(j-charCodeA)+"<\/td>");
    document.write("<\/tr>");
}
document.write("<\/table>");
</SCRIPT>
         
<P>Here's the idea. To encrypt the message:
         
<BLOCKQUOTE><p>ATTACK AT DAWN</BLOCKQUOTE>
         
<P>using the keyword &ldquo;CAT&rdquo;, we write the keyword above the message
repeatedly:

<BLOCKQUOTE>
<TABLE>
    <TR>
       <TD class="b"> <P>keyword </TD>
       <TD class="b"> <P><CODE>CATCATCATCATCA</CODE> </TD>
    </TR>
    <TR>
       <TD class="b"> <P>plaintext </TD>
       <TD class="b"> <P><CODE>ATTACK AT DAWN</CODE> </TD>
    </TR>
    <TR>
       <TD class="b"> <P>ciphertext </TD>
       <TD class="b"> <P><CODE>&nbsp; </CODE> </TD>
    </TR>
</TABLE>
</BLOCKQUOTE>
         
<P>Now, below, we compute each letter of the ciphertext by looking at the
intersection of the row of the keyword and the column of the
plaintext. (In fact, because of the way the table is set up, it doesn't
matter whether the keyword character is the row or the column.) In our
example:
         
<BLOCKQUOTE>
  <TABLE>
      <TR>
         <TD class="b"> <P>keyword </TD>
         <TD class="b"> <P><CODE>CATCATCATCATCA</CODE> </TD>
      </TR>
      <TR>
         <TD class="b"> <P>plaintext </TD>
         <TD class="b"> <P><CODE>ATTACK AT DAWN</CODE> </TD>
      </TR>
      <TR>
         <TD class="b"> <P>ciphertext </TD>
         <TD class="b"> <P><CODE>CTMCCD AM DTYN</CODE> </TD>
      </TR>
   </TABLE>
</BLOCKQUOTE>
         
<P>Notice:
         
 <UL>

 <LI>The two T's in &ldquo;ATTACK&rdquo; were encrypted differently,
 unlike the simple substitution cipher. This is why we can't just do a
 simple frequency analysis to crack the code.
            
 <LI>The letter &ldquo;A&rdquo; is encrypted four times, yielding only
 three different results, since there are only three letters in the
 keyword. If the plaintext were much longer, a sophisticated frequency
 analysis might be able to determine information about the keyword and
 plaintext.  A longer keyword would give more variety and hence more
 security.

 </UL>

<div class="ex"><span class="ex">Exercise 2</span>
         
<P>Use the table above to encrypt &ldquo;ATTACK&rdquo; using the
Vignere cipher and the keyword &ldquo;CODE&rdquo;.  Notice how the A's
and T's never have the same substitutions.

</div>
         
<P>Because a Vigen&egrave;re cipher uses more than one substitution alphabet,
it's one of a bunch of ciphers known as <em>polyalphabetic</em>.
         
<div class="ex">
  <h2 id="vigenere_exercise">Exercise Using Vigen&egrave;re Cipher</h2>

  <p>Choose a partner (say from the row in front of or behind you, so you
  can't easily look onto her monitor, though it doesn't really matter).
  One of you will be the <em>sender</em> and the other
  the <em>receiver</em>.
    <ol>
      <li>Jointly, choose a secret codeword that you'll use for encrypting
      and decrypting.
        
      <li>The sender uses this <a href="vigenere.html">vigenere form</a>
      and the secret codeword to encrypt a message.  The message can be
      anything. If you're feeling stumped, send the identity and location
      of one of the horcruxes, or a quotation from Shakespeare.

      <li>The sender then copy/pastes the ciphertext into an email message
      and emails it to the receiver.

      <li>The receiver uses the same <a href="vigenere.html">vigenere
      form</a> to decrypt a message, using the secret codeword.

      <li>Verify that the message was transmitted correctly and secretly.
    </ol>
</div>

<p>Notice that the form above only encrypts lowercase letters; it removes
anything else, including spaces.  This is partly for pedagogical reasons
(since the ciphertext is also all lowercase letters) and partly for
simplicity, since the JavaScript code doesn't have to worry about dealing
with non-printing characters in the output (ciphertext).  However, we can
simply represent each character as its ASCII code, as a two-digit hex
number.  That results in this <a href="vigenere-allchars.html">vigenere
form for all characters</a>.


<H2 id="enigma">Enigma</H2>
         
<P>The Germans in WWII used an encryption scheme based on a polyalphabetic
cipher. They built machines to do the encryption and named
them <a href="http://en.wikipedia.org/wiki/Enigma_machine"><em>Enigma</em></a>
machines.  They considered the encryption by the Enigma machine
unbreakable, and relied on it to communicate with their U-boats in the
North Atlantic.  The Enigma machine looked like manual typewriters with
keys and hammers, but internally the keys were attached to drums that did
the substitutions by &ldquo;re-wiring&rdquo;: mapping the keys to
different hammers.  Actually, there were three (later four) rotors that
did the substitutions and after each letter was typed, the rotors turned
like a car odometer (the rightmost fastest, and so forth).
         
<P>The British managed to steal several of the machines and figure out how
they worked.  (One attempt to steal one was the story of the movie U-571,
except that in the movie the Americans stole the machine, but in real life
the British were the heros.)  Unfortunately, they still needed the keyword
(the settings of the rotors). A group of mathematicians led by Alan Turing
(and including quite a few women) were able to analyze the transmissions
and, eventually, crack the code. This was a major turning point in the
war, and the Allies went to enormous effort and sacrifice to conceal the
fact that they had cracked the code.
         
<P>Here are some links about the Enigma machine, in addition to the
  Wikipedia article linked above.
         
<UL>
            
   <LI><A HREF="http://www.eclipse.net/~dhamer/Enigma1.htm">A picture 
            and some description of how it works.</A>
            
   <LI><A HREF="http://www.iwm.org.uk/">England's Imperial War Museum &mdash; search for <em>enigma</em>.
            </A>
</UL>

<H2 id="private_key">Private Key Encryption</H2>
         
<P>Now that we understand something about encryption, let's go back to our
initial scenario and see how it works. Alice wants to send a message to
Bob, without Eve or anyone else being able to read the message. She
encrypts it using the secret key, and sends it to Bob. Even if Eve
intercepts the message, she won't be able to read it. Bob uses the secret
key to decrypt the message and read what Alice says.
         
<P>Suppose that Alice is behind enemy lines and Bob is back at home
base. She gets to a radio transmitter, gets out her secret code book,
encrypts her message using today's key, and sends it to Bob. Bob has to
get out the matching code book to decrypt the message.  If Eve is able to
capture the code book, disaster!
         
<P>If Eve captures the code book, Alice needs to send a new secret key to
Bob. She needs to send it securely, so that Eve can't read it. Thus, we're
back at square one: Alice needs to send a key securely to Bob, so that she
can send a message securely to Bob. Consider the secret codes we used
earlier, when we said you could send email messages in code, just by
agreeing on a rotation amount, but if you had to send the rotation amount
by email, you're stuck!
         
<P>For thousands of years, this was the essential paradox of
encryption: you had to have a secure way of communicating in order to have
a secure way of communicating. A real-life chicken-and-egg problem!
         
<P>The kernel of the paradox is that all of the encryption methods that we
have discussed so far are kinds of <EM>private key</EM> systems: they
required a shared private key.
         
<H2 id="public_key">Public Key Encryption</H2>
         
<P>In 1976, Whitfield Diffie and Martin Hellman solved the problem of
deriving a shared private key over an insecure channel, an invention that
came to be known as Diffie-Hellman key exchange.  While it contains some
cool ideas that are still in use today, we won't purse it further in this
course.  (If you're interested, there is a good Wikipedia article on <a
href="http://en.wikipedia.org/wiki/Diffie-Hellman_key_exchange">Diffie-Hellman
key exchange</a>.)  Instead, we will discuss the RSA cryptographic system,
which has some very interesting properties.

<p>The year after Diffie and Hellman came out with their cryptographic
system, three MIT professors (Ron Rivest, Adi Shamir and Leonard Adleman)
created the first published, practical implementation of <EM>public
key</EM> cryptography. The main ideas of a public key cryptosystem are:
         
<UL>

     <LI>Instead of one key, you have <EM>two</EM>: one to encrypt and a
     different one to decrypt.
            
     <LI>The encryption key can be <EM>public</EM>.
            
     <LI>Knowing the encryption key doesn't help you figure out the
     decryption key.

</UL>
         
<P>How does this help? Very simple: Bob knows that Alice wants to send him
a message, so he creates a pair of keys.  He advertises his public key all
over the world (maybe he puts it on his web page). Alice sees it, and so
does Eve. Alice downloads it and uses it to encrypt her message. She
radios it to Bob, and Eve intercepts it, but Eve can't decrypt the
message &mdash; only Bob can.  No one but Bob can decrypt the message, because
only Bob has the secret key.
         
<p>Imagine that we send information around in lockable trunks (rather
than, say, paper envelopes).

<ul>
         
         <li>With <strong>private key encryption</strong>, there's
         <em>one</em> key for each trunk.  The same key is used to lock
         and unlock it.  Therefore, Alice and Bob have to have the same
         key.  If Alice wants to send a message securely to Bob, and he
         doesn't have the key, she needs to send him that first.  That's a
         problem.  Why?

         <li>With <strong> public key encryption </strong>, there are
         <em>two</em> keys for each trunk.  If one key is used to lock the
         trunk, it can't be used to unlock the trunk; only the
         <em>other</em> key can unlock the trunk.  They have to cancel
         each other out.  If Alice wants to send a message securely to
         Bob, she first gets his public key, maybe off his web page or
         something.  She then locks the trunk with the public key and
         sends it to Bob.  He then unlocks it with the private key!

</ul>

<p><table border=2 style="margin-left: auto; margin-right: auto">
<caption>A pictoral comparison of Private and Public Key Encryption</caption>
<tr><th> Private Key </th><th> Public Key </th></tr>
<tr>
<td valign=top><img alt="Diagram of private key encryption" src="private-key.png" WIDTH=200></td>
<td valign=top><img alt="Diagram of public key encryption" src="public-key.png" WIDTH=200></td>
</tr>
</table>

<H2 id="rsa">Implementing Public Key Encryption</H2>
         
<P>The preceding description is relatively straightforward, but the
implementation is not.  Nevertheless, several different public key systems
have been created. One system, called the RSA method, involves advanced
number theory that can cause grown men to burst into tears (or maybe it's
just me), but the idea is very cool.  (If you're interested, please
consult the Wikipedia article on
the <a href="http://en.wikipedia.org/wiki/RSA">RSA method</a>, but be
warned that the article assumes a good deal of knowledge of number theory,
though there are good examples and references.)
         
 <UL>

     <LI>The pair of keys are mathematically related, and
            
     <LI>You can reasonably efficiently generate them and use them to
     encrypt and decrypt messages, but
            
     <LI>To try to determine one key from the other involves solving a
     problem that is mathematically <q>hard</q>.

</UL>
         
<P>The last fact makes the RSA method difficult to crack.  For their
contribution, the members of the RSA team received the 2002 TURING AWARD,
which is considered the Nobel-equivalent for Computer Science.
         
<h2 id="rsa_method">The RSA Method</h2>

<p>There are many more substantive and accurate sources to learn
  about <a href="http://en.wikipedia.org/wiki/RSA_%28algorithm%29">the RSA
  method</a>, but here are a few steps that give a few more details to
  make it more concrete.

<p>To generate a key pair, do the following:
  <ol>
    <li>Choose two large prime numbers, p and q.
      
    <li>Compute n=pq. n is used as the <em>modulus</em> for both
    encryption and decryption.

    <li>Compute e, which is used for encrypting.  There are some technical
    conditions for e, but in practice it is often a prime with a simple
    bit pattern, such as 3<sub>16</sub>, 11<sub>16</sub> or
    1001<sub>16</sub>.

    <li>Compute d, which is used for decrypting.  It is the mathematical
    inverse of e when doing arithmetic mod n.  In order to compute d, you
    need to know p and q.
  </ol>

<p>To <em>encrypt</em>, you compute
  <blockquote>
    <p>c = m<sup>e</sup> (mod n)
</blockquote>

<p>To <em>decrypt</em>, you compute
  <blockquote>
    <p>m = c<sup>d</sup> (mod n)
</blockquote>

<p>The <em>public key</em> is e and n.  (Yes, there are two numbers in the
  public key.)  The <em>private key</em> or <em>secret key</em> is d.

<p>To crack this code, you have to factor n, or find some other way to
  compute d from e and n.

<h2 id="rsa_example">The RSA Cipher in JavaScript</h2>

<p>There are many implementations of the RSA method, but a very nice one
  that shows the steps of generating a key pair and also allows for
  encrypting and decrypting
  is <a href="http://www.hanewin.net/encrypt/rsa/rsa-test.htm"> Herbert
  Hanewinkel's RSA Public Key Encryption Demo</a>

<div class="ex">
  <h2 id="rsa_exercise1">Exercise Exploring RSA</h2>
  <ol>
    <li>Go to Herbert Hanewinkel's page.  
      
    <li>From the pulldown menu, choose a number of bits. This is the
    number of bits that n will be (approximately), and, because factoring
    n is the hard part, the bigger n, the stronger the encryption scheme.
    Unless you want to wait a long time, though, choose the smallest
    value, 256.
      
    <li>click on <q>generate key</q>

    <li>Notice how big the <q>Public Modulo (p*q)</q> is.  This is the
    value of n. Imagine trying to factor that to get p and q.

    <li>Skip down to below the solid line to the pair of boxes labeled
    <q>plaintext</q> and <q>ciphertext in hex</q>.  (Notice how you now
    understand what <q>hex</q> means: since the encryption is going to be
    a long string of bits, hex is incredibly useful here..)

    <li>Type in a message (plaintext) and encrypt it.  Erase the plaintext
    and decrypt it.
  </ol>
</div>

<div class="ex">
  <h2 id="rsa_exercise">Exercise Using the RSA Cipher</h2>

  <p>Let's make this a bit more realistic.  Choose a partner (say from the
  row in front of or behind you, so you can't easily look onto her
  monitor, though it doesn't really matter).  One of you will be
  the <em>sender</em> and the other the <em>receiver</em>.
    <ol>
      <li>The <em>receiver</em> uses this
      customized <a href="rsa-receiver.html">receiver</a> version of Herbert
      Hanewinkel's form to create a key pair.

      <li>She emails the public key to the sender.  Specifically, she
      emails the last field of the form above the horizontal line, the
      input labeled <q>OpenPGP Multi Precision Integer (MPI) of Public Key
      (base64)</q>.  (This is an encoding of both e and n, in one
      relatively compact representation.)
        
      <li>The sender copies the public key into this
      customized <a href="rsa-encrypt-only.html">sender</a> version of the
      RSA encryption form.  She clicks on the button to unpack e and n
      from the public key.
        
      <li>The sender encrypts her message. The message can be anything.
        If you're feeling stumped, send the identity of the important
        character who dies in <i>Harry Potter and the Half-Blood
        Prince</i> and who kills him.  This is an important secret; don't
        assume everyone has read the book.

      <li>The sender then copy/pastes the ciphertext into an email message
        and emails it to the receiver.

      <li>The receiver copy/pastes the ciphertext into the same RSA form,
      above (the one that knows the decryption key) and decrypts the
      message.

      <li>Verify that the message was transmitted correctly and secretly.
    </ol>
</div>

<p>Notice the contrast between using public key and private key
  encryption.  In private key encryption, as with Caesar and
  Vigen&egrave;re, both the sender and receiver have the key and do pretty
  much the same thing.  Thus, codes like that are
  called <em>symmetric</em> cryptosystems.  In public key encryption, on
  the other hand, the sender and receiver do very different things.  The
  receiver has to generate the public key that allows her to receive
  messages that only she can read; the sender doesn't know anything that
  Eve doesn't know.  Thus, public key systems are also
  called <em>asymmetric</em> cryptosystems.

<H2 id="breaking_rsa">Breaking RSA</H2>
         
<P>We said that breaking RSA is <q>hard,</q> but what does that mean,
really?  You have to factoring <em>n</em>, a large number.  The state of
the art is little better than trying all the possible factors to see if
they divide evenly into the number.  Suppose the number is 256 bits long,
which is roughly 76 decimal digits long.  Let's call it 80 digits.  How
many numbers would you have to try?  All the primes up to the square root
of the 80 digit number, and the square root will have 40 digits. So, it's
about
         
 <BLOCKQUOTE><p>10,000,000,000,000,000,000,000,000,000,000,000,000,000</BLOCKQUOTE>
         
<P>Yes, but computers are fast, right? Suppose we have a fast computer
that can try a billion factors every second.  A billion is a 1 followed by
9 zeroes, so to divide by a billion, we just knock off nine digits. Then
we only have to wait for
         
 <BLOCKQUOTE><p>10,000,000,000,000,000,000,000,000,000,000</BLOCKQUOTE>
         
<P>seconds. Since there are about 32 million seconds in a year, this will
only take
         
<BLOCKQUOTE><p>312,000,000,000,000,000,000,000</BLOCKQUOTE>

<P>years.

<P>The centerpiece of the RSA method uses numbers that are the products of
two very large prime numbers, forcing Eve to buy very fast computers and
wait a <EM>very</EM> long time to crack the encryption.
         
<H2 id="public_key_in_practice">Public Key Encryption in practice</H2>
         
<P>When you access a secure web server, your browser and the server become
Alice and Bob. They want to communicate securely, but they don't know each
other and they didn't make prior arrangements to have a secret
key. Instead, they use the idea of public key encryption. When the little
padlock icon closes, your browser has established a cryptographically
secure connection to the server, and so your credit card numbers and other
private information is safe from the Eves on all the network connections
between you and the server.
         
<P>Is your information safe? Not entirely. Maybe someone can hack into the
server. Maybe someone at the destination isn't trustworthy. Maybe the
server is a complete fraud, put up by Mallory. Maybe someone was looking over
your shoulder when you typed. There is probably no such thing as perfect
security. We all have to decide how much effort to put into security.
         
<P>Encryption isn't just for web traffic. It could also be used for email
and for telephone messages, including cell phones. Right now, anyone with
a radio scanner and a little know-how can listen to cell phone
conversations. Similarly, tapping a phone is very easy. Encryption lets us
use any of these insecure media to send a private message.
         
<h2 id="hybrid">Hybrid Cryptographic Systems</h2>

<p>Furthermore, note that public key encryption solves one important
  failing of private key encryption, namely the <em>key distribution
  problem</em>, but private key encryption is <em>not</em> obsolete.  The
  reason is primarily <em>speed</em>.  Public key algorithms are very
  slow, much slower than private key systems.

<p>Therefore, the way things usually work in practice (say, by HTTPS) is a
  hybrid approach:
  <ul>
    <li>The sender creates a random <q>session key</q> suitable for use by
    some private-key algorithm.
      
    <li>The sender encrypts the session key using the receiver's public
    key and securely sends the session key to the receiver.

    <li>The sender and receiver then use the session key and the private-key
    algorithm to communicate securely.

  </ul>

<H2 id="digital_signatures">Digital Signatures and Authentication</H2>
         
<P>Suppose Alice wants to send Bob the message:

<BLOCKQUOTE><p>Call off the attack, it's a trap! Signed, Alice</BLOCKQUOTE>
         
<P>She encrypts her message with Bob's public key and radios it to
him. Meanwhile, Mallory, who is malicious, sends Bob the message:
         
<BLOCKQUOTE><p>Go on with the attack, it's all clear! Signed, Alice</BLOCKQUOTE>
         
<P>She also encrypts the message with Bob's public key and radios it to
him. She's pretending to be Alice!  What is Bob to think?
         
<P>There's a cool aspect to public key encryption that we haven't
mentioned. We said that one key decrypts what the other encrypts. In fact,
both keys can encrypt, and the two keys are opposites, which means that
one can decrypt what the other encrypts.
         
<P>So, here's what Alice does: she encrypts her message with her own
<EM>private</EM> key. Bob gets it and successfully decrypts it with
Alice's <EM>public</EM> key. (She has a web site with her public key
listed.) He then realizes that <EM>only</EM> Alice could have sent this
message, since only her private key can create a message that her public
key can decrypt.
         
<P>Thus, public key encryption can give us <EM> digital signatures
</EM>. The purpose of a regular, real-life signature is that, presumably,
only you can sign your name the way you do. By comparison to a known
signature on file, your bank or any other interested party can verify that
something has been signed by you.
         
<p>The &ldquo;signing&rdquo; of digital certificates, which we
discuss in the lecture on certificates, actually uses digital
signatures just like this.  It just involves a different use of public
key encryption: a trusted third party signs the public key, using its
own private key!  This is confusing, so think about it for a while...

<P>Similarly, if there was a public key on file for a person, they can
use their private key to &ldquo;sign&rdquo; an electronic document,
even an email.
         
<h2 id="message_digest">Message Digests</h2>

<p>In practice, because public key systems are slow and verbose, people do
  not digitally sign the orginal document.  If you have a 50-page long
  legal contract, you don't want to use public key to sign it, because the
  result would be 50+ pages of gibberish and would take a long time to
  compute.

<p>Instead, they sign
  a <a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function">digest</a>
  of the document.  What is a digest?  In the field of cryptography, a
  digest of a document is something that

  <ul>

    <li>Is a <em>lot</em> smaller than the document. Typically, it's a
    fixed number of bits, such as 128.  In other words, that 50-page legal
    contract gets boiled down to just 128 bits.

    <li>Depends <em>deterministically</em> on the document.  The digest of
    a document is always the same, from time to time and place to place,
    no matter who computes it.
      
    <li>If anything about the document changes, the digest changes.  In
    other words, if you change <em>one</em> word buried deep in that 50
    page document, say <q>the customer may pay the bank...</q> to <q>the
    customer must pay the bank...</q>, the digest changes.  
  </ul>

<p>(I'm tempted to say that the digest depends on the document, the whole
  document, and nothing but the document.)

<p>Thus, for the purposes of digital signatures, it's just as good to sign
  a digest as the original document, and it saves a lot of time and space.
  Here's what happens:

  <ul>
    <li>The sender, Alice, generates a digest of the message.  Call it MD.
      
    <li>Alice uses her <em>private</em> or <em>secret</em> key to encrypt
    MD.  Call this E(MD).  This <q>signs</q> the digest.
      
    <li>Alice sends Bob (1) the message, (2) MD and (3) E(MD).

    <li>Bob re-computes the digest and compares it to MD to check whether
      the document was tampered with.  Bob also applies Alice's public key
      to E(MD) thereby decrypting it. He compares that to MD to check that
      the message and MD were really sent by Alice.
  </ul>

<p>Many message digest algorithms have been invented. As of this writing,
  cryptographic experts recommend using one of the algorithms in
  the <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a> family of
  algorithms for digital signatures.  (The algorithms differ in the number
  of bits in the digest, such as 224, 256, 384, and 512.)

<p>You can play with a JavaScript implementation of
  these <a href="http://jssha.sourceforge.net/">SHA-2 algorithms</a>.

<!-- 
<div class="ex">
  <h2 id="signature_exercise">Exercise Using Digital Signatures</h2>

  <p>Let's make this a bit more realistic.  Use the same partner as you
  used before in the RSA exercise, so your partner already knows your
  public key.  One of you will be the <em>sender</em> and the other
  the <em>receiver</em>.  The receiver is the one who knows the sender's
  public key.  If both of you know the other's public key, either can be
  the receiver.

  <ol>

    <li>The sender creates a message of some sort.
      
    <li>She uses the <a target="_blank" href="http://jssha.sourceforge.net/">SHA-2</a> page to create a digest
    of the message.

    <li>She <a  target="_blank" href="rsa-secret.html">generates a digital signature of the
    digest using her secret, private key</a>

    <li>She sends all three of these to the receiver.

    <li>The receiver <a  target="_blank" href="rsa-public.html">checks the digital
    signature of the digest using the sender's public key</a>. 

  </ol>
</div>
-->



<H2 id="key_escrow">Key Escrow</H2>
         
<P>We've been taking the side of Alice and Bob, helping them keep
information away from Eve. What if Alice and Bob are bad guys 
<!-- (maybe terrorists) -->
and Eve is the government?  What's the point of getting a court
order to tap a phone line if the conversation is encrypted?  What can Uncle
Sam do?
         
<P>Throughout the 90s, the U.S. government did several things:
         
 <UL>
 
           <LI>It categorized strong crypto systems as
            <EM>munitions</EM>, like napalm and cluster bombs, so
            that it was illegal to export them from the United States.
            That's why there were domestic versions of Netscape and
            international versions. The international version didn't
            have the high-powered crypto.
            
            <LI>It established the Data Encryption Standard (DES) and
            required computer manufacturers to use it for any
            encryption.
            
            <LI>The DES required that the government be given a copy
            of any key generated, so that law enforcement
            could decrypt any message that it deemed necessary to
            decrypt, like getting a court order to tap a
            phone.
 
 </UL>
         
<P>There was a lot of resistance.  Computer manufacturers didn't want to
have separate international and domestic versions of software.  Privacy
advocates and civil libertarians worried about the government's power to
invade privacy. (The keys would be split in half with the halves held by
different agencies, to prevent a single agency running amok and violating
civil rights.)  Practical people pointed out that the bad guys wouldn't
use crypto systems that the U.S. government had the keys to; they'd use
foreign-made crypto systems. Eventually, the government caved in, but in
our current climate, the desire to clamp down on cryptography will rise
again.
         
<H2 id="discussion">Discussion Topics</H2>
         
 <OL>

            <LI>How safe do you feel shopping online using secure
            connections? What about insecure connections?
            
            <LI>What do you think of digital signatures?
            
            <LI>Should the U.S. government allow private citizens to
            use encryption?
            
            <LI>Should the U.S. government require private citizens
            to use key escrow?
            
            <LI>Should the U.S. government forbid the export of
            strong encryption systems?

         </OL>
         
<H2 id="summary">Lesson Summary</H2>
         
 <UL>

            <LI>Encryption makes a message unreadable by those who
            lack the special key.  On computers, this is always a
            symbolic/numerical operation, such as substituting
            letters or rotating the alphabet.
            
            <LI>Ciphers (procedures for encryption) vary in how
            difficult they are to crack. Substitution ciphers and the
            like can be quite easy, depending on how much ciphertext
            there is.
            
            <LI>There are two broad categories of ciphers: private
            key and public key.
            
            <LI>Private key ciphers have the disadvantage that Alice
            and Bob have to have a secure way to tranfer the key.
            While this may be fine in many real-world applications,
            it doesn't work well across the internet.
            
            <LI>Public key ciphers allow Alice to send Bob a message
            by encrypting it with Bob's public key, so that no one
            but Bob can read it.
            
            <LI>Public key ciphers also allow Alice to sign her
            message by encrypting it with her own private key, so
            that when Bob is able to decrypt it using her public key,
            he knows it's from Alice.
            
            <LI>Key escrow systems allow the government to decrypt
            messages. There is still a lot of debate about this.
            Privacy advocates, civil libertarians and computer
            industry executives are against it. Law enforcement
            officials and others are for it.
            
            <p>What do <EM> you </EM> think?

 </UL>
         
<h2 id="further" class="stop_here">Further Information and Examples</h2>

<p>Note that beyond here is information that we think you might find
interesting and useful, but which you will not be responsible for.  It's
for the intellectually curious student.

<h2 id="triple_des">Triple DES</h2>

<p>Many more sophisticated private-key encryption schemes have been
  invented since Vigen&egrave;re and Enigma, and research continues on new
  algorithms.  (Recall that private key or symmetric encryption is still
  in constant use, in addition to or combined with public key schemes.)
  One private key algorithm, not even a particularly new one, is called
  <a href="http://en.wikipedia.org/wiki/Triple_DES">Triple DES</a>,
  because it is based on the older <em>DES</em> &mdash; Data Encryption
  Standard.  If you want to encrypt a message using a private key system,
  and you want to use something better than the Vigen&egrave;re form that
  we provide above, Triple DES is a reasonable choice.

<p>Here is a link to a form that allows you
  do <a href="http://etherhack.co.uk/symmetric/des_3des/des_3des.html">encrypt
  using Triple DES</a>.

<p>How to use it:
  <ol>
    <li>Go to the page above and generate a private key (the top box in
    the form).
      
    <li>Use a public key encryption scheme to send that key securely to
    the person you want to correspond with.
      
    <li>Either of you can then use the form and the key to encrypt
    messages to send to each other, and to decrypt messages you receive.
    Put the input (either the plaintext to encrypt or the ciphertext to
    decrypt) in the box labeled <q>input</q> and click the appropriate
    button below the box. The output appears below.
  </ol>


<H2 id="solutions">Solutions to Exercises</H2>
         
 <UL>
            <LI><A HREF="ex1.html">Exercise 1</A>
            
            <LI><A HREF="ex2.html">Exercise 2</A>
 </UL>

<!--#set var="reltop" value="../.." -->                  
<!--#include virtual="../../navigation/footer.html" -->
</BODY>
</HTML>
