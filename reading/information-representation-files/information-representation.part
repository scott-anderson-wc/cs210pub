
<!-- Minor changes by Ellen for Fall '10 - removed link to www.cstc.org for 
     more on conversion between number systems - link not working

     Minor changes by Scott:  added more interesting links about 
     high-level hardware diagrams and replaced the old diagram.

     Spring '12.  Added important section on the relationship beween size
     of the representation and its power.  Should add some exercises on
     binary.

     Fall '13, added info on volatile memory versus permanent storage.

     Spring '14, Eni broke the file into two parts: computer and information.
-->

          
 <H2 id="info_rep">How information is represented</H2>

<P>Every description of a computer needs to explain
how the computer handles information: numbers, text, pictures, sound,
movies, instructions.

<P>The computer is an electronic device. Each of its wires can either
carry electric current or... not carry current. So, like a light switch,
it understands <EM>only two states</EM>. It turns out that this is enough
to make the whole idea work. In fact, any system that can represent at
least two states can represent information. Take, for example,
the <a href="http://en.wikipedia.org/wiki/Morse_code">Morse code</a> that
is used in telegraphy. Morse is a sound transmission system that can carry
a short beep (represented by a dot) and a long beeeeeep (represented by a
dash). Any letter or number can be represented by a combination of these
two symbols. Click here to see
a <A HREF="http://www.soton.ac.uk/~scp93ch/refer/morseform.html">Morse
translator</A>.

<P>Similarly with computers. To represent a number, we use the
<EM>binary</EM> arithmetic system, not the decimal number system that
we use in everyday life. In the binary system, any number can be
represented using only two symbols, 0 and 1. (Morse is almost, but not
quite (due to the pauses between letters) a binary system.  A system
closely related to Morse is used by computers to do data
compression (more about this later). Here is how the binary numbers
correspond to our decimal numbers:</P>

<P><TABLE class="table table-bordered numbers numbers" style="width: 100px">
   <TR>
      <TH>Decimal</TH><TH>Binary</TH>
    </TR>
   <tr><td>0</td><td>0</td></tr>
   <tr><td>1</td><td>1</td></tr>
   <tr><td>2</td><td>10</td></tr>
   <tr><td>3</td><td>11</td></tr>
   <tr><td>4</td><td>100</td></tr>
   <tr><td>5</td><td>101</td></tr>
   <tr><td>6</td><td>110</td></tr>
   <tr><td>7</td><td>111</td></tr>
   <tr><td>8</td><td>1000</td></tr>
   <tr><td>9</td><td>1001</td></tr>
   <tr><td>10</td><td>1010</td></tr>
   <tr><td>11</td><td>1011</td></tr>
   <tr><td>12</td><td>1100</td></tr>
   <tr><td>13</td><td>1101</td></tr>
   <tr><td>14</td><td>1110</td></tr>
   <tr><td>15</td><td>1111</td></tr>
</table>

<P>And so on. Both systems are <EM>positional</EM>: a great idea that we
owe to Arab mathematicians, because before them, <A
HREF="http://mathforum.org/dr.math/faq/faq.roman.html">counting in
Roman</A> was tough (DCCCLXXXII + CXVIII = M, you know...)  and <A
HREF="http://www.math.tamu.edu/~dallen/history/gr_count/gr_count.html">counting
in Greek</A> was almost impossible (omega pi beta + rho iota eta = alpha).

<p>
<em>Positional</em> means that the position of each symbol within the
number determines its value. Thus, 32 is different from 23 because the 3
and the 2 are in different <em>positions</em>, and each position has
a <em>place value</em>.  You already know this, but you do it
instinctively, and we are reminding you of this because we will do the
same thing with binary numbrs.

<p>For example, you know that the meaning of the number 1492 is:
<blockquote>
<p> 1492 = 1*1000 + 4*100 + 9*10 + 2*1 = 1*10<sup>3</sup> +
  4*10<sup>2</sup> + 9*10<sup>1</sup> + 2*1<sup>0</sup>
</blockquote>

<p>Thus the meaning of every digit is defined by the power of 10 in that
 position.</p>
          
<p>Similarly, number 1101 in binary means 13 because
<blockquote>
<p>13 = 1*8 + 1*4 + 0*2 + 1*1 = 1*2<sup>3</sup> + 1*2<sup>2</sup> +
  0*2<sup>1</sup> + 1*2<sup>0</sup>
</blockquote>

<p>The numbers 8, 4, 2, 1 are, as you know, powers of 2, starting on the
   right and moving left: <code>1 = 2<sup>0</sup></code>,
    <code>2 = 2<sup>1</sup></code>,
    <code>4 = 2<sup>1</sup></code>, and <code>8 = 2<sup>3</sup></code>
</p>         

<p> The decimal system is also called "base 10" and the binary "base 2", because
  every digit in a number contributes to the whole based on the power of 10 
  (or power of 2) with which it is multiplied. 
  
<p>
Of course, we can have positional systems on different bases, like base 12
(AKA "a dozen") and base 7 (AKA a week). Very soon in this course, we'll
work with base <em>sixteen</em>.

<P>Below is a form that can help you convert between bytes (8-bit binary
numbers) and decimal numbers easily. Type in a decimal number and
press <q>enter</q> or click elsewhere on the page to update the
checkboxes. Or, click the checkboxes and watch the decimal number
change. A checked box corresponds to a bit that is <em>one</em>. An
unchecked box corresponds to a
<em>zero</em>. Try creating the number 13 by clicking on the 8, 4, and 1
checkboxes. Play around with this to get comfortable with it.

<P><!--
This file retrieved from the JS-Examples archives
http://www.js-examples.com
100s of free ready to use scripts, tutorials, forums.
Author: dickmann.org - http://www.dickmann.org/ 

Bugs fixed by Scott D. Anderson, Summer 2005

-->
<script type="text/JavaScript">

<!--

function d2b(form) {// Decimal to Binary
        j = form.decimal.value;
        for (i=0; i<8; ++i) {
                l = eval("form.a"+i);
                if (j & 1) 
                        l.checked=true;
                else
                        l.checked=false;
                        j >>>= 1;
        }
}

function b2d(form) {// Binary to Decimal
        j=0;
        for (i=7; i>=0; --i) {
                j <<= 1;
                l = eval("form.a"+i);
                if (l.checked) 
                    j |= 1;
        }
        form.decimal.value=j;
}
// -->

</script>

<FORM onsubmit="d2b(this);return false;">
   
<P><TABLE class="table table-bordered numbers" style="max-width:200px">
      <TR>
         <TD>
            Binary:
         </TD>
         <TD>
            <P><TABLE class="table-bordered">
               <TR>
                  <TD>                     128
                  </TD>
                  <TD>                     64
                  </TD>
                  <TD>                     32
                  </TD>
                  <TD>                     16
                  </TD>
                  <TD>                     8
                  </TD>
                  <TD>                     4
                  </TD>
                  <TD>                     2
                  </TD>
                  <TD>                     1
                  </TD>
               </TR>
               <TR>
                  <TD>                     <INPUT TYPE=checkbox NAME=a7 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a6 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a5 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a4 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a3 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a2 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a1 VALUE=ON onclick="b2d(this.form)">
                  </TD>
                  <TD>                     <INPUT TYPE=checkbox NAME=a0 VALUE=ON onclick="b2d(this.form)">
                  </TD>
               </TR>
            </TABLE>
         </TD>
      </TR>
      <TR>
         <TD>
            <P>Decimal:</P>
         </TD>
         <TD>            <P><INPUT TYPE=text NAME=decimal VALUE="" SIZE=20 onchange="d2b(this.form)"></P>
         </TD>
      </TR>
   </TABLE>
</FORM>

<P>What's so grand about a positional system? Arithmetic calculations are
much easier than in non-positional systems, Can you imagine what second
grade would be like if you had to calculate that XLVIII + LXVII = CXV?

<!-- The table doesn't show, need to debug this -->
<!--h2 id="binary_exercise">Exercise on Binary</h2>

<div class="ex"><span class="ex">Exercise on Binary</span>

<p>It's important to be comfortable with binary as a number system.  
  Try to calculate by the hand the following conversations, and then
  check the results by clicking on the empty cells:

<p><table id="bin_ex" class="table table-bordered numbers">
<tr><th>Decimal</th><th>Binary</th></tr>
    <script type="text/JavaScript">
function genConversionExample(dec,dec_to_bin) {
    var bin = dec.toString(2);
    var result = "<tr>";
    if( dec_to_bin ) {
        result += "<td><p>"+dec+"</td>"+
                  "<td class='hidden'><p>"+bin+"</td>";
    } else {
        result += "<td class='hidden'><p>"+dec+"</td>"+
                  "<td><p>"+bin+"</td>";
    }
    result += "</tr>";
    return result;
}

function writeConversionExample(dec,dec_to_bin) {
    document.writeln( genConversionExample(dec,dec_to_bin));
}

writeConversionExample(20,true);
writeConversionExample(18,false);
writeConversionExample(24,false);
writeConversionExample(26,true);
writeConversionExample(34,true);
writeConversionExample(36,false);
writeConversionExample(48,true);
writeConversionExample(96,true);
writeConversionExample(65,false);
writeConversionExample(198,true);
writeConversionExample(178,false);

function clicker(event) {
    alert('click on '+this);
    if ( !this.style || !this.style.visibility ) {
alert('initialize visibility: '+this.style+" and "+this.style.visibility);
       this.style.visibility = 'visible';
    }
    this.style.visibility = this.style.visibility === 'hidden' ? 'visible' : 'hidden';
}

// document.getElementById('bin_ex').onclick=clicker;

(function () {
    var table = document.getElementById('bin_ex');
    var cells = table.getElementsByClassName("hidden");
    var i;
    var kids;
    var fn = function (event) {
                 var kids = this.children;
                 var j;
                 for ( j = 0; j < kids.length; j++ ) {
                     k = kids[j];
                     k.style.visibility =
                         k.style.visibility === 'hidden' ?
                             'visible' : 'hidden';
                  }
             }
    for ( i=0; i < cells.length; i++ ) {
         cells[i].onclick = fn;
         var kids = cells[i].children;
         var j;
         for ( j=0; j < kids.length; j++ ) {
              kids[j].style.visibility = 'hidden';
         }
    }
})();
</script>
</table>
</div>

-->

<p>Here are some tutorial videos on binary numbers:
<ul>
  <li><a  target="_blank" href="https://www.youtube.com/watch?v=NAJQ3Hn8zRk">Prof. Kurmas
  from Grand Valley State University on binary numbers and hex
  numbers</a>. This is a version he edited for us. Watch the first 5
  minutes for today; the rest for next time.
  <li><a  target="_blank" href="https://www.youtube.com/watch?v=TD6lcIIOeic">Danica
  McKellar on binary numbers</a>. About five minutes long.
  <li><a  target="_blank" href="https://www.youtube.com/watch?v=LpuPe81bc2w">Someone from
  Lynda.com on binary numbers</a>.  Also about five minutes long.
</ul>

<h2 id="fundamental_relationship">Fundamental Relationship</h2>

<p>One of the key themes of this course is about <em>representations</em>.
Computers represent lots of interesting things, such as colors, pictures,
music, videos, as well as mundane things like numbers and text, or even
complex things like programs.  Ultimately, you know that, at the lowest
level of all those representations, there are <em>bits</em>.

<p>One of the important aspects of these binary representations is the
  relationship between the number of bits and the power of the
  representation.  The more bits we have, the more stuff we can
  represent. 

<p>Let's be concrete for just a minute.  You saw above that with one bit,
  you can number two things: the one labeled "zero" and the one labeled
  "one," because there are two possible patterns: {0, 1}.  With two bits,
  you can number four things, because there are four possible patterns: {
  00, 01, 10, 11 }.  With three bits, you can number <em>eight</em>
  things. (Can you list the eight patterns? Take the four patterns of two
  bits and write them twice, once as <code>0xy</code> and again
  as <code>1xy</code>.)  Thus, whenever we use an additional bit, we get
  twice as many patterns.

<p>Here's a table of the relationship between the number of bits and the
  number of patterns:

<p><table class="numbers table table-bordered" style="max-width: 300px;">
   <tr><th>Number of Bits</th><th>Number of Patterns</th></tr>
   <tr><td>1</td><td>2</td></tr>
   <tr><td>2</td><td>4</td></tr>
   <tr><td>3</td><td>8</td></tr>
   <tr><td>4</td><td>16</td></tr>
   <tr><td>5</td><td>32</td></tr>
   <tr><td>6</td><td>64</td></tr>
   <tr><td>7</td><td>128</td></tr>
   <tr><td>8</td><td>256</td></tr>
   <tr><td colspan="2">...</td></tr>
   <tr><td>16</td><td>&asymp; 65,000</td></tr>
   <tr><td colspan="2">...</td></tr>
   <tr><td>24</td><td>&asymp; 16 million</td></tr>
   <tr><td colspan="2">...</td></tr>
   <tr><td>32</td><td>&asymp; 4 billion</td></tr>
   <tr><td colspan="2">...</td></tr>
   <tr><td>N</td><td>2<sup>N</sup></td></tr>
   </table>
  
<p>This fundamental relationship is important and is also unintuitive,
  because it is <em>exponential</em>.  The last line of the table shows us
  the N bits yields 2<sup>N</sup> patterns. This is unintuitive because,
  if you double the number of bits, you don't get double the number of
  patterns, you get the <em>square</em>.  For example, double 3 bits (8
  patterns) to 6 bits, and you get 64 patterns.

<p>We'll see this relationship come up in, for example, our discussion of
  <a href="color-and-images.html#indexed_color">indexed color</a>,
  because the limits we place on the number of bits in the representation
  results in a limit on the number of colors.  This is a key idea.

<H2 id="text_rep">Text Representation</H2>

<P>Text is represented with the so-called ASCII code. Years ago, the
manufacturers of early computers decided to represent every possible
character (visible or invisible, like the space or the newline) with a
number. The result was (partially) the code you see below.</P>


<figure class="text-center">
  <img src="information-representation-files/ascii.gif"
       ALT="Part of the ASCII character set"
       class="img-thumbnail">
  <figcaption>Part of the ASCII character set table. To find the code for
  a particular character in the table, add its row number on the left (32,
  48, etc.) to its column number on top. So, for example, capital A is
  represented by decimal number 64 + 1 or 65.
  </figcaption>
</figure>     

<p>A more comprehensive ASCII table is the following, which includes
  control characters with their associated graphic symbols, and, for each
  character, its hexadecimal, decimal and binary codes:

<figure class="text-center">
      <a href="information-representation-files/images/asciitable.jpg">
        <img src="information-representation-files/images/asciitable.jpg" ALT="The ASCII character set"
           class="img-thumbnail"></a>
  <figcaption>The ASCII character set table. Click for bigger image.</figcaption>
</figure>     
<!-- Eni replaced this image with a new one that has more information.
Source for the image: http://www.ecowin.org/aulas/resources/tables/asciitable.jpg-->
          
<!--P>To find the code for a particular character in the table, add its row
number on the left (32, 48, etc.) to its column number on top. So, for
example, A is represented by decimal number 65 (i.e., 64 + 1) or binary number
01000001. The greeting "Hi!" is represented by the sequence 72 105 33 or
in binary 010010000110100100100001. Of course some care must be taken to
recognize when we are looking at a number and when we are looking at a
string of characters. But that's not difficult.-->

<p>For example the letter E has the ASCII code of 69 and a binary representation
   of 01000100. The 8 bits are depicted in groups of four, because four bits
   are used to represent a single digit in the hexadecimal system, that we 
    will discuss later.</p>
          
<p>The first two rows of the table represent so-called <em>control
    characters</em>, characters that are not visible, such as backspace
    (BS), escape (ESC), CR (carriage return - an old word for enter),
    etc. If you are interested in all acronyms, the
  <a href="http://www.asciitable.com/">AsciiTable website</a> explains them in detail.</p>


<h2>Control Characters</h2>

<p>You'll notice that the first table above starts with ASCII code 32,
which is for the space character. (Yes, even the space character needs to
be represented.)  The actual ASCII system starts at 0, but the first 32
characters are "control" characters, because they were originally used to
control the early printers.  For example, the TAB character is ASCII code
9, the line feed character (which moved the paper up) is ASCII code 10,
and the carriage return (which moved the print head back to the left edge
of the paper) is ASCII code 13. Since those characters are not interesting
in the context of this class, we've omitted them from the table.

<h2>Line Endings</h2>

<p>If all we had to worry about was characters, text representation would
be pretty straightforward.  However, text is organized into
<em>lines</em>, and for historical reasons, one of the subtle differences
among Windows, Mac and Unix/Linux is how line endings are represented.  In
the olden days before Windows, Macs and Unix, the early <a
href="http://www.columbia.edu/acis/history/teletype.html">teletype</a>
printers used two control characters at the end of each line: the carriage
return character to move the print head back to the left, and the linefeed
character to move the paper up by one line.

<p>The Mac represents the end of a line with a carriage return character.
Linux uses a line feed character.  Windows uses <em>both</em>, just like
the olden days.

<p>Usually, when you transfer a text file from system to system, the FTP
program (Fetch, WinSCP, or whatever) substitutes the appropriate line
ending.  The "text mode" of transfer says to make these substitutions;
"binary mode" makes no substitutions and is more suitable for non-text
files, such as images or programs.  Note that HTML and CSS are both kinds
of text.  Most FTP programs have a "guess which mode" setting that usually
works pretty well, but can occasionally make a mistake, which is why it's
sometimes useful to know this obscure fact. It's also why copy/pasting
between Mac and Windows often fails.

<h3>Unicode</h3>

<P>The early ASCII system had space for 256 symbols, enough to represent
all English characters, punctuation marks, numbers etc. It turns out that
there are other languages on Earth besides English, (;-) and recent
software is being written to accommodate those, too, via a much larger
code called <A
HREF="http://www.unicode.org/unicode/standard/WhatIsUnicode.html">Unicode</A>.
  We have already been using unicode when putting this tag in our HTML:
<pre>
    &lt;meta charset="utf-8" &gt;
</pre>
<p>Your <em>Head First HTML &amp; CSS</em> book talks about unicode
          on page 239.</p>
<!--You may want to read up on that in your spare time.-->

<!--H2 id="instruction_rep">Instruction Representation</H2>

<P>Once you can represent numbers and characters, you can also represent
<EM>instructions</EM>. It was this observation that led 
  <a href="http://en.wikipedia.org/wiki/Von_Neumann">von Neumann</a>and
his collaborators to create a general purpose, reprogrammable
computer. Again, one needs to keep track of when you are looking at
instructions versus a string of characters.

<P>In the future we will learn how the computer represents images, sound
and movies.-->

<H2 id="bits_bytes">Bits and Bytes</H2>

<p>Groups of bits that are used to represent characters came to be known
  as a <a href="http://en.wikipedia.org/wiki/Byte">byte</a>.  Remember
  that a byte is 8 bits.  That Wikipedia page also discusses the history
  of the word and the names for larger groups of bytes, such as

  <ul>
    <li>Kilobytes (kB), or 1000 bytes.  About a quarter of a page of
    text.
      
    <li>Megabytes (MB), or 1000 kilobytes.  About 250 small books
    worth of text.

    <li>Gigabytes (GB), which is 1000 MB.  About the amount of text in
    a small library.
  </ul>

<div class="bs-callout bs-callout-warning">
  <h4>A note on the standard abbreviations</h4>
    <ul>
      <li>Uppercase <q>B</q> is used for <em>bytes</em> while
  lowercase <q>b</q> is used for <em>bits</em>.  Network speeds, where
  bits go across a wire one at a time, are usually measured in bits per
  second, or bps.  File sizes are always in bytes, hence kB or MB.
        
      <li>The abbreviation for <q>kilo</q> is a lowercase <q>k</q>,
      hence <q>kB</q> for kilobytes.  The abbreviations for the other
      prefixes (<q>mega</q>, <q>giga</q>, <q>tera</q>, <q>peta</q> ...)
      are all uppercase:  M, G, T, P ....
    </ul>
</div>

<p>Historically, computer scientists have often used <q>kilobyte</q>
  to mean 1024 bytes, because 1024 is pretty close to 1000 and because
  bytes often come in chunks whose size is a power of 2, and
  1024=2<sup>10</sup>.  For example, if you buy a 4 GB flash drive, it
  won't hold exactly 4 billion bytes, but a bit more because of this
  difference.  Hard drives and network speeds, on the other hand, are
  usually measured in powers of 10 rather than powers of two.  In
  practice, it rarely matters.

<P>Computers these days come with huge amounts of storage space on the
  hard drive (often hundreds of GB), but they are usually able to
  process only a few GB of them at a time (their <em>main memory</em>
  or RAM).  We will use these symbols often in future lectures.
          
