<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class Activities</title>
    <!--#include virtual="../../modularity/bs-head.part" -->
    <link rel="stylesheet" type="text/css" href="http://cs.wellesley.edu/~cs307/js/google-code-prettify/prettify-sda.css">
  <script src="http://google-code-prettify.googlecode.com/svn/loader/prettify.js"></script>
  <link rel="stylesheet" href="prettify.css">
    <style>
      #TOC_list {list-style-type: none;}
    </style>
    
  </head>
  <body>
    <!--#include virtual="../../modularity/navbar.part" -->

    <div class="container">
      <h1>Encryption</h1>
      <hr>
    </div>
      
    <div class="container">
      <div class="row">
     
        <div class="col-md-3">
          <div class="bs-sidebar hidden-print" role="complementary">
            <ul class="nav bs-sidenav">  
              <div id="insert_TOC_here"></div>
            </ul>
          </div>
        </div>

        <div class="col-md-8">
          

<h2>Goal</h2>

<p>By the end of today, you should:
  <ol>
    <li>understand the terminology used when talking about encryption, decryption, and cryptography<p>
    <li>understand encryption systems that use private keys and public keys<p>
    <li>use public key encryption for your own communication<p>
    <li>be informed of the different uses of private and public key cryptography
  </ol>

<h2>Encryption Recap</h2>

<p>Foundation
  <ul>
    <li>What makes general-purpose encryption <em>possible</em> is
      that <em>everything</em> can be represented using <em>bits</em>. This
      is crucially important. 
    <li>Encryption just works on the bits; it doesn't care whether the
      bits are text, images, sound, movies, or anything else
  </ul>

<p>Kinds of Encryption:
  <ul>
    <li><strong>Symmetric</strong> or <strong>private key</strong> encryption.  The idea is relatively
    intuitive, even if the implementations are complex. Examples:
      <ul>
        <li>Caesar,
          
        <li>Vigenere,
          
        <li>Enigma
          
      </ul>

      <p>The weakness of private key encryption is <em>the key
      distribution</em> problem:
        <blockquote><p>How do you securely transmit the <em>secret
        key</em> to your interlocutor so that you can securely communicate
        with them?
        </blockquote>
      
    <li><strong>Public key</strong> or <strong>asymmetric</strong>
    encryption. The idea is revolutionary.
      <ul>
        <li>Solves the <em>key distribution problem</em>
          
        <li>How do you prove who you are without giving away your
          identity?  Solved!

        <li>Allows for <em>digital signatures</em>, which
          is <em>amazing</em>:
          <blockquote>
            <p>How can you <q>sign</q> a document without allowing others
              to forge your signature or to copy/paste your signature onto
              another document?  Solved!
          </blockquote>
      </ul>
  </ul>

  <h2>Communication using Symmetric Encryption</h2>

  <ul>
    <li>Alice and Bob somehow share a secret key, K, that Eve does not
      
    <li>Alice composes a message, M, to Bob. She encrypts it with the
    key.  She sends E<sub>K</sub>(M) to Bob.
      
    <li>Bob decrypts it with K by computing
      D<sub>K</sub>(E<sub>K</sub>(M)) = M and reads the message.
      
    <li>He can reply the same way.
  </ul>
  
  <h2>Communication using Public Key Encryption</h2>

  <ul>
    <li>Alice creates a key <em>pair</em> (P,S).  They
    are <em>inverses</em>:  S can decrypt what P encrypts (and vice
    versa).
      
    <li>Alice sends Bob her public key, P. She can send a copy to Eve,
      too.
      
    <li>Bob composes a message, M to Alice.  He encrypts it with P.  He
    sends E<sub>P</sub>(M) to Alice.

    <li>Alice decrypts it with the secret key, computing
      D<sub>S</sub>(E<sub>P</sub>(M)) = M and reads the message.
  </ul>

<p>The trick is to come up with algorithms and key pairs where knowing P
  doesn't help Eve find S.

<p>One such trick is factoring, which is the basis of the RSA
  (Rivest-Shamir-Adelman method).  If P is the product of
  two <em>very</em> large prime numbers, and S is related to those prime
  factors, Eve can only find S by factoring P.

  <h2>Digital Signatures</h2>

  <p>First, digital signatures have <em>nothing</em> to do with privacy
  and security.  Just the opposite. You may want to prove to the world
  that you signed something.  Don't confuse these.
    <ul>
      <li>Alice wants to sign a public message.  She already has a public
      key pair and everyone has P.
        
      <li>She composes the message to be signed, M.
        
      <li>She posts M and E<sub>S</sub>(M).  That is, she posts the
      message and its encryption using her <em>secret</em> key.
        
      <li>Anyone can compute D<sub>P</sub>(E<sub>S</sub>(M)) and check
      that it matches M.
        
      <li>Since <em>only</em> Alice could have created such an encrypted
      form of that message, it <em>must</em> have been signed by Alice.
    </ul>

    <p>The same idea can be used for Alice to prove her identity!  All she
    has to do is sign a message and anyone can verify that the message was
    signed by her.

<h2>Message Digests</h2>

    <p>Because digital signatures take significant computing time, in
    practice Alice doesn't sign M, but rather a <em>message digest</em>. A
    message digest algorithm puts M through a kind of deterministic
    cuisinart that reduces it to just a small number of bits, say 128 or
    256. However, the digest is (essentially) <em>unique</em>, like
    fingerprints.

    <p>Just as your fingerprint is much smaller than you, but just as
    unique as you are, message digests are smaller but uniquely identify a
    message.

      
  <h2>Quiz Question Nr. 1</h2>
  <p>Encryption is:
  <ol type="A">
    <li><p>information that cannot be read without special information
    <li><p>the process of converting plaintext into ciphertext 
    <li><p>the process of converting ciphertext into plaintext
    <li><p>the process of cracking the code with the use of a computer program
  </ol> 
          
  <h2>Quiz Question Nr. 2</h2>
  <p>Which of the following codes cannot be used in creating a cipher?
  <ol type="A">
    <li><p>The Caesar Code
    <li><p>The Vigenere Code
    <li><p>The ASCII Code
    <li><p>The Enigma Code
  </ol> 

  <h2>Quiz Question Nr. 3</h2>

  <p>Assuming a Caesar code with rotation 10 and the use of the whole ASCII set 
    of 128 characters for typing a message, which of the following numbers will
    represent the letter lowercase <strong>z</strong> (its ASCII is 122) in the ciphertext?
  <ol type="A">
    <li><p>2
    <li><p>4
    <li><p>16
    <li><p>132</p></li>
  </ol>
      
  <p>Do you see any problem with the setup described in Quiz Question Nr. 3?</p>

  <h2>Quiz Question Nr. 4</h2>

  <p>Which of the following statements about breaking the Caesar Code is TRUE?
  <ol type="A">
    <li><p>It can be broken <strong>only</strong> if we figure out the rotation amount.
    <li><p>It can be broken <strong>only</strong> with the help of a computer to execute many trial-and-error runs.
    <li><p>It can be broken with the help of ASCII encoding and the modulo operator.
    <li><p>It can be broken with the help of statistical functions. 
  </ol> 
      
<h2>Quiz Question Nr. 5</h2>
  <p>The Vigenere Cipher would work better if:
  <ol type="A">
    <li><p>the codeword is short
    <li><p>the codeword is long
    <li><p>many codewords are used for every message
    <li><p>the codeword has a predefined, fixed length
  </ol>      

 <h2>Quiz Question Nr. 6</h2>
  <p>Systems that use private keys are unbreakable. 
  <ol type="A">
    <li><p>True.
    <li><p>False.
    <li><p>Only the ones that don't use polyalphabetic ciphers. 
  </ol>
      
  <h2>Quiz Question Nr. 7</h2>
  <p>Which of the following statements is TRUE?
  <ol type="A">
    <li><p>Public key encryption is <strong>insecure</strong> because it needs two keys.
    <li><p>Public key encryption is <strong>secure</strong> because it needs two keys.
    <li><p>Public key encryption is <strong>insecure</strong> because everyone knows your public key.
    <li><p>Public key encryption is <strong>secure</strong> because no one else knows your private key.
  </ol> 
     

<h2>Task 1: Play the RSA game with a friend</h2>      
 
  <p>Instructions can be
  found <a target="_blank"
  href="http://cs.wellesley.edu/~cs110/OLD_WEBSITE/lectures/L18-encryption/#rsa_exercise">here</a>.

  <p>For simplicity, I may just demo this on a single machine, but you can
  test that I'm not cheating by doing the exercise.
      
  <h2>Quiz Question Nr. 8</h2>
  <p>Public key encryption is useful because:
  <ol type="A">
    <li><p>it is used by people who want to keep their communication secret from the government
    <li><p>it is used by websites such as Google, Facebook, Tumblr, etc.
    <li><p>it is used for financial transactions on the web
    <li><p>it is used by users who value private communication
  </ol> 

<p>But, of course, the most important thing it does is solve the <em>key
    distribution problem</em>.

  <h2>Quiz Question Nr. 9</h2>
  <p>Which of the following is TRUE:
  <ol type="A">
    <li><p>the public key encrypts a message that is decrypted by the private key
    <li><p>the private key encrypts a message that is decrypted by the public key
    <li><p>both A and B
    <li><p>neither A nor B
  </ol> 
      
   <h2>Quiz Question Nr. 10</h2>
  <p>Which of the following is TRUE about message digests:
  <ol type="A">
    <li><p>it is infeasible to find two different messages with the same digest
    <li><p>it is infeasible to modify a message without changing the digest
    <li><p>it is infeasible to recreate a message knowing its digest
    <li><p>it is easy to compute the digest for any given message
  </ol> 
      
<h2>Task 2: Practice Digital Signatures with a friend</h2>      
 
  <p>Instructions can be found <a target="_blank"
  href="http://cs.wellesley.edu/~cs110/OLD_WEBSITE/lectures/L18-encryption/#signature_exercise">here</a>.
      
<h2>Task 3: Write a Caesar encryption function</h2>

<p>The purpose of the following is to make encryption less magical by
  implementing a simple cipher.
  <ul>
    <li>Implement a function, <code>caesar</code>, taking two arguments,
    some plaintext (a string) and a rotation amount (an integer).
      
    <li>It should iterate through the string, converting each character
    and constructing another string containing the ciphertext.
      
    <li>To get the Unicode value for a character at
    position <code>i</code> in a string, use the <code>charCodeAt</code>
    method.
      
    <li>To convert a Unicode value into a character, use
    the <code>fromCharCode</code> method on the <code>String</code>
    object.
      
    <li>You may assume that the string contains only ASCII characters.
  </ul>

<div id="exbox">
<p> <textarea id="code" rows=20 cols=100>
var sample = "attack at dawn";

alert(caesar(sample,3));

// your function here:

  </textarea> 
  </p>
  <button id="exec" onclick="eval($('#code').val())">Execute Code</button> 
</div>     


<h2 id="sec_summary">Summary</h2>
<p>We hope that after these activities you can:
  <ul>
    <li>understand how encryption and decryption work
    <li>undertand the difference between private and publick key cryptography
    <li>the uses of private and public key cryptography
  </ul>


<h2 id="sec_solutions">Solutions</h2>

<p id="solutions_later">Will be posted later, visit again after
  <span id="later"></span>.</p>

<div id="solutions" style="display: none">
<pre class="prettyprint lang">
function caesar(plaintext, rotAmount) {
   ciphertext = "";
   for( i = 0; i < plaintext.length; i++ ) {
      var ch = plaintext.charCodeAt(i); // the Unicode/ASCII value
      var enc = (ch+rotAmount)%128;     // Unicode/ASCII value of encrypted
      ciphertext += String.fromCharCode(enc);
   }
   return ciphertext;                   
}
</pre>
 

</div>
<script>
var now = new Date();
var later = new Date("4/30/2015 5:00 PM");
document.querySelector("#later").innerHTML = later.toLocaleString();
if( now > later ) {
    document.querySelector("#solutions").style.display = "block"; // $("#solutions").show();
    document.querySelector("#solutions_later").style.display = "hidden"; // $("#solutions").show();
}
</script>

      </div><!-- end of row -->
    </div><!-- end of class=container -->



    <!--#include virtual="../../modularity/bs-footer.part" -->
    <script src="../../js/TOC.js"></script>
    <script src="/~cs307/js/google-code-prettify/prettify.js"></script>
    <script>insertTOC_textual(); prettyPrint();</script>
    <script>
      function hideItem() {
          // hide a PRE or a P inside the LI (this). Don't hide the
          // whole LI, or the numbering changes.
          $(this)
              .find("pre,p")
              .css('border-color','red')
              .css('background-color','#FF8080')
              .fadeOut(1000);
      }

      $("li").click(hideItem);
    </script>
   </div>
  </div>
  <!--#include virtual="/~cs110/modularity/footer.part" -->
 </div> <!--end of container>
        
        
 <!--#include virtual="/~cs110/modularity/bs-footer.part" -->
  </body>
</html>
